---
layout: 
title:  "CSS 이해하기"
---
왜 기우는 거지

## 2021.7.26

왜 기우는 거지

> # 0. CSS 소개
> - **CSS** : Cascading Style Sheets
> - 마크업 언어(HTML)이 웹페이지의 뼈대를 구성한다면, CSS는 그것을 꾸미는 역할
> - CSS는 HTML과 독립된 다른 언어이지만, 마크업 문서를 표현하는 언어이기 때문에 늘 HTML과 묶어서 이야기함.
> - 같은 내용을 가진 하나의 HTML 문서도 다양한 CSS를 통해 모양이 바뀌는 것을 확인할 수 있음.
> 
> 
> 
> ## 0.1. CSS 기본 형식
> 
>  ```css
>  h1 {color: yellow; font-size:2em;}
>  ```
> 
> - 선택자(selector) : h1
> - 속성과 값 : color:yellow;  = 선언(declaration)
> - 선언부(declaration block) = 선언들 ('{}')
> - 규칙 : 선택자+선언부
> 
>  ※ HTML의 속성(Attribute) ≠ CSS의 속성(Property)
>  
> 
>  
> ## 0.2. CSS의 적용 (꾸미는 방식)
>  
>  (1) **Inline** - (직접선언) 해당 요소에 직접 스타일 속성 선언
>  ```html
>  <dic style="color:red;">내용</div>
>  ```
>  - 해당 요소에 직접 스타일 속성을 선언하기 때문에, 선택자x / 선언부에 내용만 입력
>  - 코드의 재활용 불가(자주 사용x)
>  
>  
>  (2) **Internal** - (내부선언) 문서 내에 <style> 요소로 속성 적용
>  ```css
>  <style> div {color:red;} </style>
>  ```
>  - 문서의 ```<head>```에 ```<style>```요소를 선언하여 모든 ```<div>```에 같은 스타일 규칙 적용
>  - 하지만, 페이지가 많고 스타일 규칙 내용이 많아 모든 페이지마다 저마다의 규칙을 선언하기는 쉽지 않음.
>   
>   
>  (3) **External** - (외부선언) 외부 스타일 시트 파일 연결
>  ```css
>  div {color:red;}     /*외부 스타일 시트 파일*/
>  <link rel="stylesheet" href="css/style.css">
>  ```
>  - 외부 스타일 시트란, 스타일 규칙들을 별도의 외부 파일에 담아 넣은 것 (확장자 .css)
>  - 외부 스타일 시트 방식이면, 많은 페이지가 있더라도 이 한 줄로 모든 페이지에 같은 스타일 적용 가능.
>  - **rel 속성** : 연결되는 파일이 문서와 어떤 관계인지를 명시하는 속성으로, CSS파일은 'stylesheet'라고 적어야 함.
>  
>   
>  (4) **Import** - (불러오기) 
>   
> ```css
> @import url("css/style.css");
>  ```
>   
>  - 스타일 시트 내에 다른 스타일 시트 파일을 불러오는 방식
>  - ```<style>``` 내부 상단이나 외부 스타일 시트 파일 상단에 선언하는데 거의 사용x

  
 * * *
  
> # 1. CSS 문법
>   
> ## 1.1 기본 선택자 (요소, 태그) - ```*```
> ```css
> h1 {color: yellow;}
> * {color: yellow;}
> h1,h2,h3,h4,h5,h6 {color: yellow; font-size:2em;}
> ```
> - 선택자 부분에 들어가는 것에 따라 '요소 선택자', '태그 선택자'라고도 불림.
> - 전체 선택자, **```*```(별표, asterisk)**를 통해 문서 내에 있는 모든 요소를 선택할 수 있어 매우 편리하지만, 성능이 좋지 않아 사용을 지양함.
> - 선택자끼리, 선언끼리 그룹화 가능.
> 
> ## 1.2. class 선택자 - ```.```
> ```css
> .foo {font-size: 30px;}
> .bar {color: blue;}
> 
> <p class="foo">내용</p>
> <p class ="foo bar">내용</p>
> ```
> - 기본 선택자만 쓰면 같은 요소끼리는 같은 스타일 규칙이 적용되는 단점이 있음.
> - 이에, 요소에 구애받지 않고 스타일을 적용하는 가장 일반적인 방법이 class 선택자.
> - HTML의 요소에 class 속성을 추가하여(여러개 가능) CSS에서 그 속성 값(foo)을 선택자를 지정.
> - 클래스 선택자를 쓸 때는, 맨 앞에 .(마침표)를 찍어야 함.
> 
> ## 1.3. id 선택자 - ```#```
> ```css, html
> #bar {background-color: yellow;}
> 
> <p id="bar">내용</p>
> ```
> - class 선택자와 비슷하며, class 속성 대신 id 속성을 쓰면 됨.
> - class 선택자와의 가장 큰 차이점은, class와 달리 id는 문서 내에서 유일해야한다는 점임.
> - 즉, id 선택자로 규칙을 적용할 수 있는 요소는 단 하나뿐.
> 
> ## 1.4. 선택자끼리의 조합
> ```css
>   p.bar{...}         /* 요소 + class */
>   .foo.bar{...}      /* class + class */
>   #foo.bar{...}      /* id + class */
> ```
> 
> ## 1-5. 속성 선택자
>   (1) 단순 속성으로 선택 : [속성의 이름]
>   ```css
>   p[class] { color: silver; }   /* class속성이 있는 <p>요소에 모두 적용 */
>   p[class][id] { text-decoration: underline; }  /* class, id 속성 둘다 있는 <p>요소에 모두 적용 */
>   
>   <p class="foo">Hello</p>
>   <p class="bar">CSS</p>
>   <p class="baz" id="title">HTML</p>
>   ```
>   
>   (2) 정확한 속성으로 선택 : [속성의 이름="속성의 값"]
  
>   ```css
>   p[class="foo"] { color: silver; }
>   p[id="title"] { text-decoration: underline; }
>   ```
>   
>   (3) 부분 속성값으로 선택
> - **[class~="color"]** : class 속성의 값이 공백으로 구분한 "color" 단어(오직 color만, colorful 안됨)가 포함되는 요소 선택
> - **[class^="color"]** : class 속성의 값이 "color"로 시작하는 요소 선택
> - **[class$="color"]** : class 속성의 값이 "color"로 끝나는 요소 선택
> - **[class*="color"]** : class 속성의 값이 "color" 문자가 포함되는 요소 선택
> 
>   
> ## 1-6. 문서 구조 관련 선택자
>   : 문서의 구조를 이해하려면 '부모와 자식 관계(바로 위, 바로 아래)'와 '조상과 자손 관계(위로 쭉, 아래로 쭉)', '형제관계(동등한 레벨)', '인접한 형제 관계(동등한 레벨 중에서 앞뒤로 나올 때)'가 있음을 알아야 함.
>   
>   (1) **자손 선택자 - ```' '```(공백)**
>   ```css
>   div span { color: red; }
>   ```
>   : <div>의 자손 요소인 <span>을 선택하는 선택자임.
>   
>   (2) **자식 선택자 - ```>```(꺽쇠 기호)**
>   ```css
>   div > h1 {color:red;}
>   ```
>   : <div>의 자식 요소인 <h1>을 선택하는 선택자임.
>   
>   (3) **인접 형제 선택자 - ```+```**
>   ```css
>   div + p {color:red;}
>   ```
>   : <div>와 인접한 형제 관계인 <p>선택
>   
>   +)
>   ```css
>   body > div table + ul { ... }
>   /* body요소의 자식인 div요소의 자손인 table요소의 인접한 형제 관계인 ul 선택 */
>   ```

  * * *
  
> # 2. CSS 문법 - 가상 선택자
>   - 가상 선택자에는 '가상 클래스'와 '가상 요소'가 있음.
>   
> ## 2.1. 가상 클래스 - ```:```(콜론 기호)
>   - 가상 클래스란(pseudo class), 흔하게 사용되는 여러 동작 패턴에 대하여 미리 정해놓은 스타일이 적용되도록 약속된 보이지 않는 클래스임.
>   
>   **(1) 문서 구조 관련된 가상 클래스**
>   - **:first-child** : 첫 번째 자식 요소 선택
>   - **:last-child** : 마지막 자식 요소 선택
  
>   ```css
>   <ul>
>     <li>HTML</li>
>     <li>CSS</li>
>     <li>JS</li>
>   </ul>
>   li:first-child { color: red; }
>   li:last-child { color: blue; }
>   ```
>   
>   **(2) 앵커 요소와 관련된 가상 클래스**
>   - :link : 하이퍼링크(앵커 요소 내의 href 속성)이면서 아직 방문하지 않은 앵커
>   - :visited : 이미 방문한 하이퍼링크를 의미
>   ```css
>   a:link { color: blue; }
>   a:visited { color: gray; }
>   ```
>   
>   **(3) 사용자 동작과 관련된 가상 클래스**
>   - **:focus** : 현재 입력 초점(입력 폼에 마우스 클릭이나 키보드 탭 키로 요소 탐색)을 가진 요소에 적용
>  - **:hover** : 마우스 포인터가 있는(마우스를 올렸을 때) 요소에 적용
>   - **:active** : 사용자 입력(버튼이나 링크 등을 마우스로 클릭)으로 활성화된 요소에 적용
>   
>   
> ## 2.2. 가상 요소 - ```:```(콜론 기호) / ```::```(더블 콜론 기호)(~CSS3부터)
>   : 가상 요소(pseudo element)란, HTML <body> 코드에 존재하지 않는 구조 요소에 스타일 부여 가능.
>  
>   ```css
>   p::before { content: "###" }
>   p::after { content: "!!!" }
>   p::first-line { color:yellow; }
>   p::first-letter { font-size:3em; }
>   ```
> 
>   - **:before** : 가장 앞에 요소를 삽입     ← content 속성 필요
>   - **:after** : 가장 뒤에 요소를 삽입      ← content 속성 필요
>   - **:first-line** : 요소의 첫 번째 줄에 있는 텍스트
>   - **:first-letter** : 블록 레벨 요소의 첫 번째 문자
  
* * *  

> # 3. CSS 문법 - 구체성
>   : 만약 같은 요소를 선택하는 서로 다른 중복된 스타일 요소가 있다면 어떻게 될까?   
>     → 구체성(선택자를 얼마나 명시적으로, 구체적으로 선언했는지를 수치화한 것)의 값이 큰 요소부터 우선으로 적용됨.
>   
>   - **!important** : 모든 구체성을 무시하고 우선권을 가짐. 인라인 방식으로 표기
>   - 1, 0, 0, 0 : 요소에 직접 스타일 속성을 선언한 **인라인 방식**
>   - 0, 1, 0, 0 : 선택자에 있는 모든 **'id'** 속성값
>   - 0, 0, 1, 0 : 선택자에 있는 모든 **'class'** 속성값, 기타 속성, 가상 클래스
>   - 0, 0, 0, 1 : 선택자에 있는 모든 **'요소'**, 가상 요소
>   - 0, 0, 0, 0 : **전체 선택자(*)**
>   - 조합자는 구체성에 영향을 주지 않는다. (>, + 등)
>   
> ```css
> h1 { ... }         /* <h1>요소 하나 = 0,0,0,1 */
> body h1 { ... }         /* <body>, <h1>요소 둘 = 0,0,0,2 */
> .grape { ... }         /* grape 클래스 하나 = 0,0,1,0 */
> *.bright { ... }         /* 전체 선택자(*) + bright 클래스 = 0,0,1,0 */
> p.bright em.dark { ... }         /* <p>,<em>요소 + bright,dark 클래스 =  0,0,2,2 */
> #page { ... }         /* page id 하나 = 0,1,0,0 */
> div#page { ... }         /* div 요소 + page id = 0,1,0,1 */
> ```
 
* * *
  
> # 4. CSS 문법 - 상속
>   - 상속은 말그대로, 부모의 속성이 자식에게도 적용이 되는 것.
>   - 그러나, 모든 속성이 다 상속되는 것은 아님.(margin 등 박스 모델 속성 등)
>   - 상속된 속성은 아무런 구체성을 가지지 못함.
>   
>   ```css
>   * { color: red; }
>   h1#page { color: gray; }
>   
>   <h1 id="page">Hello, <em>CSS</em></h1>    /* 회색글씨 Hello, 빨간글씨 CSS */
>   ```
  
* * *  

> # 5. CSS 문법 - 캐스케이딩
>   - 캐스케이딩(cascading)이란, 스타일 규칙들이 어떠한 기준을 통해 단계적으로 요소에 적용되는지를 정한 규칙임.
>   1. '중요도(!impoirtant)'가 명시적으로 선언된 규칙을 우선함.
>   2. 스타일 규칙들의 '출서'에 따라 분류함.
>       : CSS 출처는 제작자(사이트 개발자)와 사용자(웹 페이지를 방문한 일반 사용자), 사용자 에이전트(일반 사용자의 환경, 즉 브라우저에 내장된 CSS)로 나뉨.   
>       : 제작자 스타일 규칙이 사용자 에이전트 스타일 규칙보다 우선함.
>   3. 스타일 규칙들의 '구체성' 값이 클수록 우선함.
>   4. 스타일 규칙의 '선언 순서'가 뒤에 있을 수록 우선함.

  
  
